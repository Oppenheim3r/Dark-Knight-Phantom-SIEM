"""
Dark Knight Phantom SIEM - Detection Models
Advanced behavioral detection and alerting
"""
from django.db import models
from django.utils import timezone
from datetime import timedelta
import uuid
import json


class DetectionRule(models.Model):
    """
    Detection rules for identifying threats
    """
    SEVERITY_CHOICES = [
        ('LOW', 'Low'),
        ('MEDIUM', 'Medium'),
        ('HIGH', 'High'),
        ('CRITICAL', 'Critical'),
    ]
    
    RULE_TYPE_CHOICES = [
        ('THRESHOLD', 'Threshold - Count exceeds limit'),
        ('SEQUENCE', 'Sequence - Events in order'),
        ('PATTERN', 'Pattern - Specific event patterns'),
        ('CORRELATION', 'Correlation - Multiple related events'),
    ]
    
    CATEGORY_CHOICES = [
        ('AUTHENTICATION', 'Authentication Attacks'),
        ('PRIVILEGE_ESCALATION', 'Privilege Escalation'),
        ('LATERAL_MOVEMENT', 'Lateral Movement'),
        ('PERSISTENCE', 'Persistence'),
        ('DEFENSE_EVASION', 'Defense Evasion'),
        ('CREDENTIAL_ACCESS', 'Credential Access'),
        ('DISCOVERY', 'Discovery'),
        ('EXECUTION', 'Execution'),
        ('COLLECTION', 'Collection'),
        ('EXFILTRATION', 'Exfiltration'),
        ('IMPACT', 'Impact'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255, unique=True)
    description = models.TextField()
    severity = models.CharField(max_length=20, choices=SEVERITY_CHOICES, default='MEDIUM')
    rule_type = models.CharField(max_length=20, choices=RULE_TYPE_CHOICES)
    category = models.CharField(max_length=50, choices=CATEGORY_CHOICES)
    
    # Rule Logic (JSON)
    logic = models.JSONField(help_text="Detection logic configuration")
    
    # MITRE ATT&CK Mapping
    mitre_tactic = models.CharField(max_length=100, blank=True)
    mitre_technique = models.CharField(max_length=50, blank=True)
    mitre_subtechnique = models.CharField(max_length=50, blank=True)
    
    # Rule Settings
    enabled = models.BooleanField(default=True)
    is_builtin = models.BooleanField(default=False)
    
    # Thresholds for reducing false positives
    cooldown_minutes = models.IntegerField(default=15, help_text="Minutes before same alert can trigger again")
    min_confidence = models.IntegerField(default=70, help_text="Minimum confidence score (0-100)")
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    created_by = models.CharField(max_length=100, default='system')
    
    # Statistics
    total_alerts = models.IntegerField(default=0)
    false_positives = models.IntegerField(default=0)
    
    class Meta:
        db_table = 'detection_rules'
        ordering = ['category', 'name']
    
    def __str__(self):
        return f"[{self.severity}] {self.name}"
    
    @property
    def false_positive_rate(self):
        if self.total_alerts == 0:
            return 0
        return round((self.false_positives / self.total_alerts) * 100, 2)


class DetectionAlert(models.Model):
    """
    Alerts generated by detection rules
    """
    STATUS_CHOICES = [
        ('NEW', 'New'),
        ('INVESTIGATING', 'Investigating'),
        ('RESOLVED', 'Resolved'),
        ('FALSE_POSITIVE', 'False Positive'),
        ('ESCALATED', 'Escalated'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    rule = models.ForeignKey(DetectionRule, on_delete=models.CASCADE, related_name='alerts')
    
    # Alert Details
    title = models.CharField(max_length=500)
    description = models.TextField()
    severity = models.CharField(max_length=20)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='NEW')
    
    # Affected Entities
    hostname = models.CharField(max_length=255, db_index=True)
    user_name = models.CharField(max_length=255, blank=True, db_index=True)
    source_ip = models.GenericIPAddressField(null=True, blank=True, db_index=True)
    target_user = models.CharField(max_length=255, blank=True)
    
    # Evidence
    matched_events = models.JSONField(default=list, help_text="List of event IDs that triggered this alert")
    event_count = models.IntegerField(default=0)
    evidence = models.JSONField(default=dict, help_text="Additional context and evidence")
    
    # Confidence Score (0-100)
    confidence = models.IntegerField(default=80)
    
    # Timestamps
    triggered_at = models.DateTimeField(auto_now_add=True, db_index=True)
    first_event_time = models.DateTimeField(null=True, blank=True)
    last_event_time = models.DateTimeField(null=True, blank=True)
    resolved_at = models.DateTimeField(null=True, blank=True)
    
    # Investigation
    assigned_to = models.CharField(max_length=100, blank=True)
    notes = models.TextField(blank=True)
    resolution_notes = models.TextField(blank=True)
    
    class Meta:
        db_table = 'detection_alerts'
        ordering = ['-triggered_at']
        indexes = [
            models.Index(fields=['status', 'severity']),
            models.Index(fields=['triggered_at', 'status']),
        ]
    
    def __str__(self):
        return f"[{self.severity}] {self.title}"
    
    def mark_false_positive(self):
        self.status = 'FALSE_POSITIVE'
        self.resolved_at = timezone.now()
        self.save()
        # Update rule statistics
        self.rule.false_positives += 1
        self.rule.save(update_fields=['false_positives'])


class EntityTracker(models.Model):
    """
    Tracks entity behavior for detection
    Aggregates events per entity within time windows
    """
    ENTITY_TYPE_CHOICES = [
        ('USER', 'User Account'),
        ('HOST', 'Hostname'),
        ('SOURCE_IP', 'Source IP'),
        ('TARGET_USER', 'Target User'),
        ('PROCESS', 'Process'),
        ('SERVICE', 'Service'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    entity_type = models.CharField(max_length=20, choices=ENTITY_TYPE_CHOICES, db_index=True)
    entity_value = models.CharField(max_length=500, db_index=True)
    hostname = models.CharField(max_length=255, blank=True, db_index=True)
    
    # Event Tracking (JSON: {event_id: count, ...})
    event_counts = models.JSONField(default=dict)
    
    # Unique values tracking (JSON: {field: [values], ...})
    unique_values = models.JSONField(default=dict)
    
    # Time Window
    window_start = models.DateTimeField(db_index=True)
    window_end = models.DateTimeField()
    
    # Last Event Info
    last_event_id = models.BigIntegerField(null=True, blank=True)
    last_event_time = models.DateTimeField(null=True, blank=True)
    
    # Related Event IDs for evidence
    event_ids = models.JSONField(default=list)
    
    class Meta:
        db_table = 'entity_trackers'
        unique_together = ['entity_type', 'entity_value', 'hostname', 'window_start']
        indexes = [
            models.Index(fields=['entity_type', 'entity_value', 'window_start']),
        ]
    
    def __str__(self):
        return f"{self.entity_type}:{self.entity_value} ({self.window_start})"
    
    def increment_event(self, event_id: int, event_db_id: int = None):
        """Increment count for an event ID"""
        event_id_str = str(event_id)
        if event_id_str not in self.event_counts:
            self.event_counts[event_id_str] = 0
        self.event_counts[event_id_str] += 1
        
        if event_db_id and event_db_id not in self.event_ids:
            self.event_ids.append(event_db_id)
            # Keep only last 100 event IDs
            if len(self.event_ids) > 100:
                self.event_ids = self.event_ids[-100:]
    
    def add_unique_value(self, field: str, value: str):
        """Track unique values for a field"""
        if not value:
            return
        if field not in self.unique_values:
            self.unique_values[field] = []
        if value not in self.unique_values[field]:
            self.unique_values[field].append(value)
    
    def get_event_count(self, event_id: int) -> int:
        """Get count for specific event ID"""
        return self.event_counts.get(str(event_id), 0)
    
    def get_total_count(self, event_ids: list = None) -> int:
        """Get total count for all or specific event IDs"""
        if event_ids:
            return sum(self.event_counts.get(str(eid), 0) for eid in event_ids)
        return sum(self.event_counts.values())
    
    def get_unique_count(self, field: str) -> int:
        """Get count of unique values for a field"""
        return len(self.unique_values.get(field, []))


class AlertSuppressionRule(models.Model):
    """
    Rules to suppress known false positives
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    
    # What to suppress
    detection_rule = models.ForeignKey(DetectionRule, on_delete=models.CASCADE, null=True, blank=True)
    
    # Conditions (JSON: field -> value patterns)
    conditions = models.JSONField(help_text="Conditions for suppression")
    
    # Settings
    enabled = models.BooleanField(default=True)
    expires_at = models.DateTimeField(null=True, blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.CharField(max_length=100)
    reason = models.TextField(help_text="Reason for suppression")
    
    class Meta:
        db_table = 'alert_suppression_rules'
    
    def __str__(self):
        return self.name
    
    def is_active(self):
        if not self.enabled:
            return False
        if self.expires_at and self.expires_at < timezone.now():
            return False
        return True



